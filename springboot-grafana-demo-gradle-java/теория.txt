1.  Библиотека java.util.concurrent.*. Коллекции для работы с многопоточностью.
Concurrent Collections
Обычные наборы данных, реализующих интерфейсы List, Set и Map нельзя использовать в многопоточных приложениях, если требуется синхронизация, т.е. такие коллекции недопустимы для одновременного чтения и изменения данных разными потоками.
Пакет java.util.concurrent предлагает свой набор потокобезопасных классов, допускающих разными потоками одновременное чтение и внесение изменений. Итераторы классов данного пакета представляют данные на определенный момент времени и не вызывают исключение ConcurrentModificationException. Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. Этим гарантируется, что при проходе итератором по коллекции не будет ConcurrentModificationException. Следует помнить, что при копировании массива копируются только ссылки на объекты.
CopyOnWriteArrayList реализует алгоритм CopyOnWrite и является потокобезопасным аналогом ArrayList. Класс CopyOnWriteArrayList содержит изменяемую ссылку на неизменяемый массив, обеспечивая преимущества потокобезопасности без необходимости использования блокировок. Т.е. при выполнении модифицирующей операции CopyOnWriteArrayList создаёт новую копию списка и гарантирует, что её итераторы вернут состояние списка на момент создания итератора и не вызовут ConcurrentModificationException.
ConcurrentHashMap<K, V> реализует интерфейс java.util.concurrent.ConcurrentMap и отличается от HashMap и Hashtable внутренней структурой хранения пар key-value. СoncurrentHashMap использует несколько сегментов, и данный класс можно рассматривать как группу HashMap’ов. По умолчанию количество сегментов равно 16. Доступ к данным определяется по сегментам, а не по объекту. Итераторы данного класса фиксируют структуру данных на момент начала его использования.
CopyOnWriteArraySet выполнен на основе CopyOnWriteArrayList с реализацией интерфейса Set.
ConcurrentNavigableMap расширяет возможности интерфейса NavigableMap для использования в многопоточных приложениях; итераторы класса декларируются как потокобезопасные и не вызывают ConcurrentModificationException.
ConcurrentSkipListMap является аналогом коллекции TreeMap с сортировкой данных по ключу и с поддержкой многопоточности.
ConcurrentSkipListSet выполнен на основе ConcurrentSkipListMap с реализацией интерфейса Set.
Queues
Неблокирующие и блокирующие очереди для работы в многопоточной среде. Неблокирующие очереди сосредоточены на скорости и работе без блокирования потоков:
ConcurrentLinkedQueue
ConcurrentLinkedDeque
Блокирующие очереди подходят для работы, когда нужно “притормозить” потоки Producer или Consumer. Например, в той ситуации, когда не выполнены какие-то из условий, очередь пуста или переполнена, или же нет свободного Consumer'a.
ArrayBlockingQueue
LinkedBlockingQueue
LinkedBlockingDeque
SynchronousQueue и др.
2.  HikariCP – что это и для чего используется. Какие есть альтернативы. Как работать в Java с HikariCP.
HikariCP
Быстрый, простой, надежный. HikariCP - это готовый к производству пул соединений JDBC с нулевыми накладными расходами, это очень легкая (примерно 130 КБ) и молниеносная среда пула соединений JDBC, разработанная Бреттом Вулдриджем примерно в 2012 году.
Фреймворк такой быстрый, потому что были применены следующие методы:
Разработка на уровне байт-кода - была выполнена некоторая экстремальная разработка на уровне байт-кода (включая собственное кодирование на уровне сборки).
Микрооптимизации — хотя их едва можно измерить, в совокупности эти оптимизации повышают общую производительность.
Интеллектуальное использование платформы коллекций — ArrayList <Statement> был заменен настраиваемым классом FastList, который устраняет проверку диапазона и выполняет сканирование удаления от начала до конца.
Микро оптимизации
В HikariCP много микро оптимизаций. По отдельности они, конечно же, не делают картины. Но все вместе сильно увеличивают общую производительность. Некоторые из этих оптимизаций — это доли микросекунды для миллионов вызовов.
